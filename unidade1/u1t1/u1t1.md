# Detec√ß√£o de bordas em imagens

> desenvolvimento de um algoritmo para detec√ß√£o de borda em imagens (processamento de imagem)

**obs**: O Arquivo original desenvolvido pelo professor **Diogo Pinheiro Fernandes Pedrosa (diogo.pedrosa@ufrn.br)** est√° neste [link](https://drive.google.com/file/d/1dVhv4gRqLFQR_x1HROlrY6U14ozjzdnD/view?usp=sharing). Este repositorio ser√° uma maneira de adapar o que esta no arquivo para o github, ent√£o pode ser que tenha se√ß√µes copiadas do arquivo original.

## üß© Contextualiza√ß√£o

A √°rea de processamento e an√°lise de imagens digitais teve um grande avan√ßo nos primeiros anos do s√©culo XXI, impulsionado pela pesquisa e desenvolvimento de tecnologias para √°reas como medicina, biologia, automa√ß√£o industrial e sensoriamento remoto. O processamento digital de imagens envolve t√©cnicas para capturar, representar e transformar imagens com computadores, permitindo extrair informa√ß√µes e melhorar a qualidade visual. Uma etapa importante desse processo √© a segmenta√ß√£o, que identifica √°reas de interesse na imagem, como bordas ou regi√µes. A detec√ß√£o de bordas, por exemplo, busca identificar limites entre regi√µes com diferentes intensidades de pixels. Isso √© feito atrav√©s de opera√ß√µes de convolu√ß√£o com m√°scaras, como os operadores de Prewitt, que s√£o amplamente utilizados para essa finalidade.

## üîç Detec√ß√£o de bordas

A tarefa de **detec√ß√£o de bordas** consiste em determinar o limite, ou fronteira, entre duas regi√µes
com propriedades e caracter√≠sticas distintas das intensidades dos pixels da imagem.
Considerando que a imagem consiste em um array **M por N**, no qual podem-se definir as
dire√ß√µes x e y, a detec√ß√£o de bordas poder√° ser obtida atrav√©s de uma opera√ß√£o de
**convolu√ß√£o** entre uma m√°scara (que configura-se como um operador) que √© aplicado sobre um
pixel de interesse da imagem e tamb√©m em seus pixels vizinhos. H√° diversos operadores para
realizar essa tarefa. Um exemplo s√£o os **operadores de Prewitt**, dados pelas matrizes a seguir:

$$
\text{Gx} = 
\begin{bmatrix}
-1 & 0 & 1 \\
-1 & 0 & 1 \\
-1 & 0 & 1 \\
\end{bmatrix}
$$

$$
\text{Gy} = 
\begin{bmatrix}
-1 & -1 & -1 \\
0 & 0 & 0 \\
1 & 1 & 1 \\
\end{bmatrix}
$$

onde **Gx** e **Gy** s√£o as m√°scaras para detec√ß√£o de bordas nas dire√ß√µes x e y da imagem digital. A imagem final segmentada √© dada pela jun√ß√£o das imagens das duas bordas obtidas.

### üî∂ Vamos fazer um pequeno exemplo de detec√ß√£o de bordas

Como foi dito anteriormente, precisamos fazer a opera√ß√£o de **convolu√ß√£o** da masc√°ra (operadores de Prewitt) com cada pixel da imagem. A convolu√ß√£o digital entre sinais √© dada pela express√£o:

$$
y[n] = x[n] * h[n] = \sum_{k=-\infty}^{\infty} x[k] \cdot h[n-k]
$$

ü§î Antes de interpretamos a forma da convolu√ß√£o para a nossa aplica√ß√£o, devemos levantar algumas considera√ß√µes antes:

- Nossa imagem precisa esta em **escala de cinza**, ou seja, os valores para cada pixel dever√° ser representado por um valor discreto que deve est√° no intervalo de **0**(preto) a **255**(branco).

- Os pixels que se encontram na borda da imagem n√£o s√£o calculados, pois para realizar o calculo da convolu√ß√£o nos pixels das bordas, precisamos acessar os pixels que est√£o nas laterais do pixel principal a ser calculado, ou seja, em algumas situa√ß√µes n√£o temos acesso aos pixels nescessarios para realizar o calculo. podemos ver isso na imagem a seguir: 

<p align="center">
    <img width=350 src="../u1t1/bordas.png"/>
</p>

com essas considera√ß√µes feitas, a convolu√ß√£o da imagem por uma mascara √© representada pelo ![Badge](https://img.shields.io/badge/-GIF-orange)
 abaixo:

<p align="center">
    <img width=350 src="../u1t1/convolucao_img.gif"/>
</p>

Como estamos fazendo a convolu√ß√£o entre matrizes, devemos multiplicar os elementos com indicies equivalentes da mascara com a matriz conrrespondente a imagem e no final fazer a somat√≥ria total.

**lembrando que isso foi apenas para um pixel e na dire√ß√£o de Y, devemos fazer esse procedimento para todos os pixels da imagem e tamb√©m para o eixo X**.

Ent√£o j√° que agora sabemos como fazer para um pixel especifico, vamos generalizar tanto para o eixo x como para o y? simboraa...

#### Eixo üáæ

Se pegarmos o exemplo que foi feito no gif temos:

$$
pixel[4][4] = (-pixel[3][3] - pixel[3][4] - pixel[3][5]) + (pixel[5][3] + pixel[5][4] + pixel[5][5])
$$

Perceba que no primeiro termo da soma, temos que a linha continua em `3`, que √© **4-1=3**. e que a coluna come√ßa de **4-1=3** e vai at√© **4+1=5**. Uma coisa semelhante acontece na outra parcela da soma, mas ao inves da linha ser 3 √© 5 que √© **4+1=5**.

agora vamos substituir por valores genericos **i** e **j**:

$$
pixel[i][j] = (-pixel[i-1][j-1] - pixel[i-1][j] - pixel[i-1][j+1]) + (pixel[i+1][j-1] + pixel[i+1][j] + pixel[i+1][j+1])
$$

#### Eixo üáΩ

Fazendo os mesmos procedimentos e usando como mascara a matriz **Gx**, temos a seguinte express√£o generica para um pixel de uma imagem em escala de cinza:

$$
pixel[i][j] = (-pixel[i-1][j-1] - pixel[i][j-1] - pixel[i+1][j-1]) + (pixel[i-1][j+1] + pixel[i][j+1] + pixel[i+1][j+1])
$$

**‚ö†Ô∏è observa√ß√µes**:

- quando um valor do pixel for maior que 255 ele ser√° colocado com o valor de 255;
- se o valor do pixel calculado for menor que zero, seu valor ser√° o m√≥dulo desse valor;
- como n√£o podemos calcular os pixels das bordas, dado uma matriz (M x N) devemos percorrer as linhas de 1 at√© M-2 e as colunas de 1 at√© N-2.

## üí° Solu√ß√£o

Nesta se√ß√£o, voc√™ encontrar√° as solu√ß√µes para os problemas propostos relacionados √† detec√ß√£o de bordas de imagem utilizando processos e threads:

- [üìå Solu√ß√£o usando Processos](https://github.com/CarlosG18/so_dca0108/blob/main/unidade1/u1t1/processo/u1t1_process.md)

- [üìå Solu√ß√£o usando Threads](https://github.com/CarlosG18/so_dca0108/blob/main/unidade1/u1t1/thread/u1t1_threads.md)