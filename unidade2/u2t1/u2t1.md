# Escalonamento de Processos

> Criando um simulador de Escalonamento de processos e fazendo uma compara√ß√£o de tempo de CPU e espera dos algoritmos de escalonamento

**obs**: O Arquivo original desenvolvido pelo professor **Diogo Pinheiro Fernandes Pedrosa (diogo.pedrosa@ufrn.br)** est√° neste [link](https://drive.google.com/file/d/18vYf0ccvCcuMHlE9YhA0CefsRRTLw8U8/view?usp=drivesdk). Este repositorio ser√° uma maneira de adapar o que esta no arquivo para o github, ent√£o pode ser que tenha se√ß√µes copiadas do arquivo original.

## üß© Contextualiza√ß√£o

O escalonamento de processos √© uma t√©cnica essencial nos sistemas operacionais modernos, permitindo que m√∫ltiplos processos compartilhem a CPU de maneira eficiente. Isso √© feito atrav√©s de algoritmos que determinam a ordem e o tempo de execu√ß√£o de cada processo, visando maximizar a utiliza√ß√£o da CPU e minimizar o tempo de resposta e espera.

## üéØ Objetivo

O objetivo desta atividade √© explorar e entender o funcionamento dos principais algoritmos de escalonamento de processos atrav√©s da simula√ß√£o de um conjunto de processos. Ser√£o aplicados diferentes algoritmos para observar e comparar seus impactos no tempo de espera dos processos.

### üî∂ Algoritmos de escalonamento:

Vamos trabalhar com quatro algoritmos de escalonamento que s√£o amplamente utilizados em sistemas operacionais:

#### [1/4] üîπ FCFS (Fist Came, First Served)

O algoritmo First Came, First Served (FCFS), como o nome sugere, seleciona os processos para execu√ß√£o na ordem em que chegam √† fila de prontos. Esse m√©todo √© simples, mas pode resultar em tempos de espera elevados se processos longos forem colocados na fila antes de processos curtos.

#### [2/4] üîπ SJF (Shortest Job First)

O algoritmo Shortest Job First (SJF) prioriza os processos com menor tempo de execu√ß√£o. Embora eficiente em termos de tempo m√©dio de espera, esse algoritmo pode ser injusto para processos mais longos, resultando em starvation (quando processos nunca s√£o executados).

#### [3/4] üîπ Round Robin (quantum = 10 u.t)

No Round Robin (RR), a CPU √© alocada para processos em ciclos de tempo fixo, chamados de quantum. Com um quantum de 10 unidades de tempo, cada processo tem a oportunidade de executar por esse per√≠odo antes que a CPU passe para o pr√≥ximo processo na fila. Esse m√©todo √© equitativo, mas pode aumentar o overhead devido √† troca constante de contexto.

#### [4/4] üîπ Round Robin (quantum = 100 u.t)

Esse √© uma varia√ß√£o do Round Robin, mas com um quantum mais longo de 100 unidades de tempo. Isso pode reduzir o overhead de troca de contexto, mas processos com tempo de execu√ß√£o muito maior ou menor que o quantum podem ter seu desempenho prejudicado.

## üí° Solu√ß√£o

Para ilustrar o funcionamento desses algoritmos, foi desenvolvido um notebook que implementa a simula√ß√£o dos diferentes m√©todos de escalonamento. Voc√™ pode acessar o c√≥digo completo e execut√°-lo para observar os resultados:

- [![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)]() - Notebook com a **Simula√ß√£o do Escalonamento de processos**

## üìà Resultados

Os resultados da simula√ß√£o mostram como cada algoritmo afeta o tempo de espera dos processos. Abaixo est√° um exemplo visual dos resultados obtidos:

<p align="center">
    <img width=200 src=""/>
</p>